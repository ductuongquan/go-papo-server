package  app

import (
	"bitbucket.org/enesyteam/papo-server/einterfaces"
	"bitbucket.org/enesyteam/papo-server/facebook_graph"
	"bitbucket.org/enesyteam/papo-server/mlog"
	"bitbucket.org/enesyteam/papo-server/model"
	"bitbucket.org/enesyteam/papo-server/store"
	"bitbucket.org/enesyteam/papo-server/utils"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
)

const (
	TOKEN_TYPE_PASSWORD_RECOVERY  = "password_recovery"
	TOKEN_TYPE_VERIFY_EMAIL       = "verify_email"
	TOKEN_TYPE_TEAM_INVITATION    = "team_invitation"
	TOKEN_TYPE_GUEST_INVITATION   = "guest_invitation"
	TOKEN_TYPE_CWS_ACCESS         = "cws_access_token"
	PASSWORD_RECOVER_EXPIRY_TIME  = 1000 * 60 * 60      // 1 hour
	TEAM_INVITATION_EXPIRY_TIME   = 1000 * 60 * 60 * 48 // 48 hours
	IMAGE_PROFILE_PIXEL_DIMENSION = 128
	INVITATION_EXPIRY_TIME        = 1000 * 60 * 60 * 48 // 48 hours
)

func (s *Server) IsFirstUserAccount() bool {
	cachedSessions, err := s.sessionCache.Len()
	if err != nil {
		return false
	}
	if cachedSessions == 0 {
		count, err := s.Store.User().Count(model.UserCountOptions{IncludeDeleted: true})
		if err != nil {
			mlog.Error("There was a error fetching if first user account", mlog.Err(err))
			return false
		}
		if count <= 0 {
			return true
		}
	}

	return false
}

func (a *App) IsFirstUserAccount() bool {
	return a.Srv().IsFirstUserAccount()
}

func (a *App) GetUser(userId string) (*model.User, *model.AppError) {
	return a.Srv().Store.User().Get(userId)
}

func (a *App) DeleteToken(token *model.Token) *model.AppError {
	err := a.Srv().Store.Token().Delete(token.Token)
	if err != nil {
		return model.NewAppError("DeleteToken", "app.recover.delete.app_error", nil, err.Error(), http.StatusInternalServerError)
	}
	return nil
}

func (a *App) PatchUser(userId string, patch *model.UserPatch, asAdmin bool) (*model.User, *model.AppError) {
	user, err := a.GetUser(userId)
	if err != nil {
		return nil, err
	}

	user.Patch(patch)

	updatedUser, err := a.UpdateUser(user, true)
	if err != nil {
		return nil, err
	}

	a.sendUpdatedUserEvent(*updatedUser)

	return updatedUser, nil
}

//func (a *App) UpdateLocale(userId string, locale string) (string, *model.AppError) {
//
//	result := <-a.Srv.Store.User().UpdateLocale(userId, locale)
//	if result.Err != nil {
//		return "", result.Err
//	}
//	newLocale := result.Data.(string)
//
//	return newLocale, nil
//}

func (a *App) sendUpdatedUserEvent(user model.User) {
	adminCopyOfUser := user.DeepCopy()
	a.SanitizeProfile(adminCopyOfUser, true)
	adminMessage := model.NewWebSocketEvent(model.WEBSOCKET_EVENT_USER_UPDATED, "", "", "", nil)
	adminMessage.Add("user", *adminCopyOfUser)
	adminMessage.Broadcast.ContainsSensitiveData = true
	a.Publish(adminMessage)

	a.SanitizeProfile(&user, false)
	message := model.NewWebSocketEvent(model.WEBSOCKET_EVENT_USER_UPDATED, "", "", "", nil)
	message.Add("user", user)
	message.Broadcast.ContainsSanitizedData = true
	a.Publish(message)
}

func (a *App) UpdateUser(user *model.User, sendNotifications bool) (*model.User, *model.AppError) {
	prev, err := a.Srv().Store.User().Get(user.Id)
	if err != nil {
		return nil, err
	}

	if !CheckUserDomain(user, *a.Config().TeamSettings.RestrictCreationToDomains) {
		if !prev.IsGuest() && !prev.IsLDAPUser() && !prev.IsSAMLUser() && user.Email != prev.Email {
			return nil, model.NewAppError("UpdateUser", "api.user.update_user.accepted_domain.app_error", nil, "", http.StatusBadRequest)
		}
	}

	if !CheckUserDomain(user, *a.Config().GuestAccountsSettings.RestrictCreationToDomains) {
		if prev.IsGuest() && !prev.IsLDAPUser() && !prev.IsSAMLUser() && user.Email != prev.Email {
			return nil, model.NewAppError("UpdateUser", "api.user.update_user.accepted_guest_domain.app_error", nil, "", http.StatusBadRequest)
		}
	}

	// Don't set new eMail on user account if email verification is required, this will be done as a post-verification action
	// to avoid users being able to set non-controlled eMails as their account email
	newEmail := ""
	if *a.Config().EmailSettings.RequireEmailVerification && prev.Email != user.Email {
		newEmail = user.Email

		_, err = a.GetUserByEmail(newEmail)
		if err == nil {
			return nil, model.NewAppError("UpdateUser", "store.sql_user.update.email_taken.app_error", nil, "user_id="+user.Id, http.StatusBadRequest)
		}

		//  When a bot is created, prev.Email will be an autogenerated faked email,
		//  which will not match a CLI email input during bot to user conversions.
		//  To update a bot users email, do not set the email to the faked email
		//  stored in prev.Email.  Allow using the email defined in the CLI
		if !user.IsBot {
			user.Email = prev.Email
		}
	}

	userUpdate, err := a.Srv().Store.User().Update(user, false)
	if err != nil {
		return nil, err
	}

	if sendNotifications {
		if userUpdate.New.Email != userUpdate.Old.Email || newEmail != "" {
			if *a.Config().EmailSettings.RequireEmailVerification {
				fmt.Println("should send verification email")
				// TODO: Check this
				//a.Srv().Go(func() {
				//	if err := a.SendEmailVerification(userUpdate.New, newEmail, ""); err != nil {
				//		mlog.Error("Failed to send email verification", mlog.Err(err))
				//	}
				//})
			} else {
				a.Srv().Go(func() {
					if err := a.Srv().EmailService.sendEmailChangeEmail(userUpdate.Old.Email, userUpdate.New.Email, userUpdate.New.Locale, a.GetSiteURL()); err != nil {
						mlog.Error("Failed to send email change email", mlog.Err(err))
					}
				})
			}
		}

		if userUpdate.New.Username != userUpdate.Old.Username {
			a.Srv().Go(func() {
				if err := a.Srv().EmailService.sendChangeUsernameEmail(userUpdate.Old.Username, userUpdate.New.Username, userUpdate.New.Email, userUpdate.New.Locale, a.GetSiteURL()); err != nil {
					mlog.Error("Failed to send change username email", mlog.Err(err))
				}
			})
		}
	}

	a.InvalidateCacheForUser(user.Id)

	return userUpdate.New, nil
}

func (app *App) CreateUserAsAdmin(user *model.User) (*model.User, *model.AppError) {
	ruser, err := app.CreateUser(user)
	if err != nil {
		return nil, err
	}

	//if err := a.SendWelcomeEmail(ruser.Id, ruser.Email, ruser.EmailVerified, ruser.Locale, a.GetSiteURL()); err != nil {
	//	mlog.Error(err.Error())
	//}

	return ruser, nil
}

func (a *App) GetUserByAuth(authData *string, authService string) (*model.User, *model.AppError) {
	return a.Srv().Store.User().GetByAuth(authData, authService)
}

func (a *App) CreateUserFromSignup(user *model.User, redirect string) (*model.User, *model.AppError) {
	if err := a.IsUserSignUpAllowed(); err != nil {
		return nil, err
	}

	if !a.IsFirstUserAccount() && !*a.Config().TeamSettings.EnableOpenServer {
		err := model.NewAppError("CreateUserFromSignup", "api.user.create_user.no_open_server", nil, "email="+user.Email, http.StatusForbidden)
		return nil, err
	}

	user.EmailVerified = false

	ruser, err := a.CreateUser(user)
	if err != nil {
		return nil, err
	}

	if err := a.Srv().EmailService.sendWelcomeEmail(ruser.Id, ruser.Email, ruser.EmailVerified, ruser.Locale, a.GetSiteURL(), redirect); err != nil {
		mlog.Error("Failed to send welcome email on create user from signup", mlog.Err(err))
	}

	return ruser, nil
}

func (app *App) IsUserSignUpAllowed() *model.AppError {
	if !*app.Config().EmailSettings.EnableSignUpWithEmail || !*app.Config().TeamSettings.EnableUserCreation {
		err := model.NewAppError("IsUserSignUpAllowed", "api.user.create_user.signup_email_disabled.app_error", nil, "", http.StatusNotImplemented)
		return err
	}
	return nil
}

func (a *App) createUser(user *model.User) (*model.User, *model.AppError) {
	user.MakeNonNil()

	if err := a.IsPasswordValid(user.Password); user.AuthService == "" && err != nil {
		return nil, err
	}

	ruser, err := a.Srv().Store.User().Save(user)
	if err != nil {
		mlog.Error("Couldn't save the user", mlog.Err(err))
		return nil, err
	}

	if user.EmailVerified {
		if err := a.VerifyUserEmail(ruser.Id, user.Email); err != nil {
			mlog.Error("Failed to set email verified", mlog.Err(err))
		}
	}

	pref := model.Preference{UserId: ruser.Id, Category: model.PREFERENCE_CATEGORY_TUTORIAL_STEPS, Name: ruser.Id, Value: "0"}
	if err := a.Srv().Store.Preference().Save(&model.Preferences{pref}); err != nil {
		mlog.Error("Encountered error saving tutorial preference", mlog.Err(err))
	}

	ruser.Sanitize(map[string]bool{})
	return ruser, nil

	//user.MakeNonNil()
	//
	//if err := app.IsPasswordValid(user.Password); user.AuthService == "" && err != nil {
	//	return nil, err
	//}
	//result := <-app.Srv.Store.User().Save(user)
	//if result.Err != nil {
	//	mlog.Error(fmt.Sprintf("Couldn't save the user err=%v", result.Err))
	//	return nil, result.Err
	//}
	//ruser := result.Data.(*model.User)
	//
	////if user.EmailVerified {
	////	if err := a.VerifyUserEmail(ruser.Id); err != nil {
	////		mlog.Error(fmt.Sprintf("Failed to set email verified err=%v", err))
	////	}
	////}
	//
	//pref := model.Preference{UserId: ruser.Id, Category: model.PREFERENCE_CATEGORY_TUTORIAL_STEPS, Name: ruser.Id, Value: "0"}
	//if presult := <-app.Srv.Store.Preference().Save(&model.Preferences{pref}); presult.Err != nil {
	//	mlog.Error(fmt.Sprintf("Encountered error saving tutorial preference, err=%v", presult.Err.Message))
	//}
	//
	//ruser.Sanitize(map[string]bool{})
	//return ruser, nil
}

// CheckUserDomain checks that a user's email domain matches a list of space-delimited domains as a string.
func CheckUserDomain(user *model.User, domains string) bool {
	if len(domains) == 0 {
		return true
	}

	domainArray := strings.Fields(strings.TrimSpace(strings.ToLower(strings.Replace(strings.Replace(domains, "@", " ", -1), ",", " ", -1))))

	for _, d := range domainArray {
		if strings.HasSuffix(strings.ToLower(user.Email), "@"+d) {
			return true
		}
	}

	return false
}

func (a *App) CreateUser(user *model.User) (*model.User, *model.AppError) {
		return a.createUserOrGuest(user, false)
	//if !user.IsLDAPUser() && !user.IsSAMLUser() && !CheckUserDomain(user, *app.Config().TeamSettings.RestrictCreationToDomains) {
	//	return nil, model.NewAppError("CreateUser", "api.user.create_user.accepted_domain.app_error", nil, "", http.StatusBadRequest)
	//}
	//
	//user.Roles = model.SYSTEM_USER_ROLE_ID
	//
	//// Below is a special case where the first user in the entire
	//// system is granted the system_admin role
	//result := <-app.Srv.Store.User().GetTotalUsersCount()
	//if result.Err != nil {
	//	return nil, result.Err
	//}
	//if result.Data.(int64) <= 0 {
	//	user.Roles = model.SYSTEM_ADMIN_ROLE_ID + " " + model.SYSTEM_USER_ROLE_ID
	//}
	//
	//if _, ok := utils.GetSupportedLocales()[user.Locale]; !ok {
	//	user.Locale = *app.Config().LocalizationSettings.DefaultClientLocale
	//}
	//
	//ruser, err := app.createUser(user)
	//if err != nil {
	//	return nil, err
	//}
	//// This message goes to everyone, so the teamId, channelId and userId are irrelevant
	//message := model.NewWebSocketEvent(model.WEBSOCKET_EVENT_NEW_USER, "", "", "", nil)
	//message.Add("user_id", ruser.Id)
	//app.Publish(message)
	//
	//return ruser, nil
}

func (a *App) createUserOrGuest(user *model.User, guest bool) (*model.User, *model.AppError) {
	user.Roles = model.SYSTEM_USER_ROLE_ID
	if guest {
		user.Roles = model.SYSTEM_GUEST_ROLE_ID
	}

	if !user.IsLDAPUser() && !user.IsSAMLUser() && !user.IsGuest() && !CheckUserDomain(user, *a.Config().TeamSettings.RestrictCreationToDomains) {
		return nil, model.NewAppError("CreateUser", "api.user.create_user.accepted_domain.app_error", nil, "", http.StatusBadRequest)
	}

	if !user.IsLDAPUser() && !user.IsSAMLUser() && user.IsGuest() && !CheckUserDomain(user, *a.Config().GuestAccountsSettings.RestrictCreationToDomains) {
		return nil, model.NewAppError("CreateUser", "api.user.create_user.accepted_domain.app_error", nil, "", http.StatusBadRequest)
	}

	// Below is a special case where the first user in the entire
	// system is granted the system_admin role
	count, err := a.Srv().Store.User().Count(model.UserCountOptions{IncludeDeleted: true})
	if err != nil {
		return nil, err
	}
	if count <= 0 {
		user.Roles = model.SYSTEM_ADMIN_ROLE_ID + " " + model.SYSTEM_USER_ROLE_ID
	}

	if _, ok := utils.GetSupportedLocales()[user.Locale]; !ok {
		user.Locale = *a.Config().LocalizationSettings.DefaultClientLocale
	}

	ruser, err := a.createUser(user)
	if err != nil {
		return nil, err
	}
	// This message goes to everyone, so the teamId, channelId and userId are irrelevant
	message := model.NewWebSocketEvent(model.WEBSOCKET_EVENT_NEW_USER, "", "", "", nil)
	message.Add("user_id", ruser.Id)
	a.Publish(message)

	//if pluginsEnvironment := a.GetPluginsEnvironment(); pluginsEnvironment != nil {
	//	a.Srv().Go(func() {
	//		pluginContext := a.PluginContext()
	//		pluginsEnvironment.RunMultiPluginHook(func(hooks plugin.Hooks) bool {
	//			hooks.UserHasBeenCreated(pluginContext, user)
	//			return true
	//		}, plugin.UserHasBeenCreatedId)
	//	})
	//}

	return ruser, nil
}

// IsUsernameTaken checks if the username is already used by another user. Return false if the username is invalid.
func (a *App) IsUsernameTaken(name string) bool {
	if !model.IsValidUsername(name) {
		return false
	}

	if _, err := a.Srv().Store.User().GetByUsername(name); err != nil {
		return false
	}

	return true
}

func (a *App) CreateOAuthUser(service string, userData io.Reader, facebookToken string, teamId string) (*model.User, *facebookgraph.FacebookError, *model.AppError) {
	if !*a.Config().TeamSettings.EnableUserCreation {
		return nil, nil, model.NewAppError("CreateOAuthUser", "api.user.create_user.disabled.app_error", nil, "", http.StatusNotImplemented)
	}

	provider := einterfaces.GetOauthProvider(service)
	if provider == nil {
		return nil, nil, model.NewAppError("CreateOAuthUser", "api.user.create_oauth_user.not_available.app_error", map[string]interface{}{"Service": strings.Title(service)}, "", http.StatusNotImplemented)
	}
	user := provider.GetUserFromJson(userData)

	if user == nil {
		return nil, nil, model.NewAppError("CreateOAuthUser", "api.user.create_oauth_user.create.app_error", map[string]interface{}{"Service": service}, "", http.StatusInternalServerError)
	}

	suchan := make(chan store.StoreResult, 1)
	euchan := make(chan store.StoreResult, 1)
	go func() {
		userByAuth, err := a.Srv().Store.User().GetByAuth(user.AuthData, service)
		suchan <- store.StoreResult{Data: userByAuth, Err: err}
		close(suchan)
	}()
	go func() {
		userByEmail, err := a.Srv().Store.User().GetByEmail(user.Email)
		euchan <- store.StoreResult{Data: userByEmail, Err: err}
		close(euchan)
	}()

	found := true
	count := 0
	for found {
		if found = a.IsUsernameTaken(user.Username); found {
			user.Username = user.Username + strconv.Itoa(count)
			count++
		}
	}

	if result := <-suchan; result.Err == nil {
		return result.Data.(*model.User), nil, nil
	}

	if result := <-euchan; result.Err == nil {
		authService := result.Data.(*model.User).AuthService
		if authService == "" {
			return nil, nil, model.NewAppError("CreateOAuthUser", "api.user.create_oauth_user.already_attached.app_error", map[string]interface{}{"Service": service, "Auth": model.USER_AUTH_SERVICE_EMAIL}, "email="+user.Email, http.StatusBadRequest)
		}
		return nil, nil, model.NewAppError("CreateOAuthUser", "api.user.create_oauth_user.already_attached.app_error", map[string]interface{}{"Service": service, "Auth": authService}, "email="+user.Email, http.StatusBadRequest)
	}

	user.EmailVerified = true
	//// thêm facebook token
	user.FacebookToken = facebookToken

	ruser, err := a.CreateUser(user)
	if err != nil {
		return nil, nil, err
	}

	if len(teamId) > 0 {
		err = a.AddUserToTeamByTeamId(teamId, user)
		if err != nil {
			return nil, nil, err
		}

		//err = a.AddDirectChannels(teamId, user)
		//if err != nil {
		//	mlog.Error("Failed to add direct channels", mlog.Err(err))
		//}
	}

	return ruser, nil, nil

	//if !*app.Config().TeamSettings.EnableUserCreation {
	//	return nil, nil, model.NewAppError("CreateOAuthUser", "api.user.create_user.disabled.app_error", nil, "", http.StatusNotImplemented)
	//}
	//
	//provider := einterfaces.GetOauthProvider(service)
	//
	//if provider == nil {
	//	return nil, nil, model.NewAppError("CreateOAuthUser", "api.user.create_oauth_user.not_available.app_error", map[string]interface{}{"Service": strings.Title(service)}, "", http.StatusNotImplemented)
	//}
	//
	//user := provider.GetUserFromJson(userData)
	//
	//if user == nil {
	//	return nil, nil, model.NewAppError("CreateOAuthUser", "api.user.create_oauth_user.create.app_error", map[string]interface{}{"Service": service}, "", http.StatusInternalServerError)
	//}
	//
	//suchan := app.Srv.Store.User().GetByAuth(user.AuthData, service)
	//euchan := app.Srv.Store.User().GetByEmail(user.Email)
	//
	//// không cần check username
	////found := true
	////count := 0
	////for found {
	////	if found = a.IsUsernameTaken(user.Username); found {
	////		user.Username = user.Username + strconv.Itoa(count)
	////		count++
	////	}
	////}
	//
	//if result := <-suchan; result.Err == nil {
	//	return result.Data.(*model.User), nil, nil
	//}
	//
	//if result := <-euchan; result.Err == nil {
	//	authService := result.Data.(*model.User).AuthService
	//	if authService == "" {
	//		return nil, nil, model.NewAppError("CreateOAuthUser", "api.user.create_oauth_user.already_attached.app_error", map[string]interface{}{"Service": service, "Auth": model.USER_AUTH_SERVICE_EMAIL}, "email="+user.Email, http.StatusBadRequest)
	//	}
	//	return nil, nil, model.NewAppError("CreateOAuthUser", "api.user.create_oauth_user.already_attached.app_error", map[string]interface{}{"Service": service, "Auth": authService}, "email="+user.Email, http.StatusBadRequest)
	//}
	//
	//user.EmailVerified = true
	//
	//// thêm facebook token
	//user.FacebookToken = facebookToken
	//
	//ruser, err := app.CreateUser(user)
	//if err != nil {
	//	return nil, nil, err
	//}
	//
	//if len(teamId) > 0 {
	//	// Cần fix
	//	//err = a.AddUserToTeamByTeamId(teamId, user)
	//	//if err != nil {
	//	//	return nil, err
	//	//}
	//	//
	//	//err = a.AddDirectChannels(teamId, user)
	//	//if err != nil {
	//	//	mlog.Error(err.Error())
	//	//}
	//}
	//
	//return ruser, nil, nil
}

// GetTotalUsersStats is used for the DM list total
func (a *App) GetTotalUsersStats(viewRestrictions *model.ViewUsersRestrictions) (*model.UsersStats, *model.AppError) {
	count, err := a.Srv().Store.User().Count(model.UserCountOptions{
		IncludeBotAccounts: true,
		ViewRestrictions:   viewRestrictions,
	})
	if err != nil {
		return nil, err
	}
	stats := &model.UsersStats{
		TotalUsersCount: count,
	}
	return stats, nil
}

func (a *App) GetUserByUsername(username string) (*model.User, *model.AppError) {
	result, err := a.Srv().Store.User().GetByUsername(username)
	if err != nil && err.Id == "store.sql_user.get_by_username.app_error" {
		err.StatusCode = http.StatusNotFound
		return nil, err
	}
	return result, nil
}

func (a *App) GetUserByEmail(email string) (*model.User, *model.AppError) {
	user, err := a.Srv().Store.User().GetByEmail(email)
	if err != nil {
		if err.Id == "store.sql_user.missing_account.const" {
			err.StatusCode = http.StatusNotFound
			return nil, err
		}
		err.StatusCode = http.StatusBadRequest
		return nil, err
	}
	return user, nil
}

func (a *App) UpdateOAuthUserAttrs(userData io.Reader, user *model.User, provider einterfaces.OauthProvider, service string, facebookToken string) *model.AppError {
	oauthUser := provider.GetUserFromJson(userData)
	if oauthUser == nil {
		return model.NewAppError("UpdateOAuthUserAttrs", "api.user.update_oauth_user_attrs.get_user.app_error", map[string]interface{}{"Service": service}, "", http.StatusBadRequest)
	}

	userAttrsChanged := false

	// luôn cập nhật facebook token cho mỗi lần đăng nhập
	if len(facebookToken) > 0 {
		user.FacebookToken = facebookToken
		userAttrsChanged = true
	}

	if oauthUser.Username != user.Username {
		if existingUser, _ := a.GetUserByUsername(oauthUser.Username); existingUser == nil {
			user.Username = oauthUser.Username
			userAttrsChanged = true
		}
	}

	if oauthUser.GetFullName() != user.GetFullName() {
		user.FirstName = oauthUser.FirstName
		user.LastName = oauthUser.LastName
		userAttrsChanged = true
	}

	if oauthUser.Email != user.Email {
		if existingUser, _ := a.GetUserByEmail(oauthUser.Email); existingUser == nil {
			user.Email = oauthUser.Email
			userAttrsChanged = true
		}
	}

	if user.DeleteAt > 0 {
		// Make sure they are not disabled
		user.DeleteAt = 0
		userAttrsChanged = true
	}

	if userAttrsChanged {
		users, err := a.Srv().Store.User().Update(user, true)
		if err != nil {
			return err
		}

		user = users.New
		a.InvalidateCacheForUser(user.Id)
	}

	return nil
}

func (app *App) UpdatePasswordAsUser(userId, currentPassword, newPassword string) *model.AppError {
	user, err := app.GetUser(userId)
	if err != nil {
		return err
	}

	if user == nil {
		err = model.NewAppError("updatePassword", "api.user.update_password.valid_account.app_error", nil, "", http.StatusBadRequest)
		return err
	}

	if user.AuthData != nil && *user.AuthData != "" {
		err = model.NewAppError("updatePassword", "api.user.update_password.oauth.app_error", nil, "auth_service="+user.AuthService, http.StatusBadRequest)
		return err
	}

	if err := app.doubleCheckPassword(user, currentPassword); err != nil {
		if err.Id == "api.user.check_user_password.invalid.app_error" {
			err = model.NewAppError("updatePassword", "api.user.update_password.incorrect.app_error", nil, "", http.StatusBadRequest)
		}
		return err
	}

	T := utils.GetUserTranslations(user.Locale)

	return app.UpdatePasswordSendEmail(user, newPassword, T("api.user.update_password.menu"))
}

func (app *App) UpdatePasswordSendEmail(user *model.User, newPassword, method string) *model.AppError {
	if err := app.UpdatePassword(user, newPassword); err != nil {
		return err
	}

	// Cần fix
	//a.Go(func() {
	//	if err := a.SendPasswordChangeEmail(user.Email, method, user.Locale, a.GetSiteURL()); err != nil {
	//		mlog.Error(err.Error())
	//	}
	//})

	return nil
}

func (a *App) UpdatePassword(user *model.User, newPassword string) *model.AppError {
	if err := a.IsPasswordValid(newPassword); err != nil {
		return err
	}

	hashedPassword := model.HashPassword(newPassword)

	if err := a.Srv().Store.User().UpdatePassword(user.Id, hashedPassword); err != nil {
		return model.NewAppError("UpdatePassword", "api.user.update_password.failed.app_error", nil, err.Error(), http.StatusInternalServerError)
	}

	a.InvalidateCacheForUser(user.Id)

	return nil
}

func (a *App) userDeactivated(userId string) *model.AppError {
	if err := a.RevokeAllSessions(userId); err != nil {
		return err
	}

	a.SetStatusOffline(userId, false)

	user, err := a.GetUser(userId)
	if err != nil {
		return err
	}

	// when disable a user, userDeactivated is called for the user and the
	// bots the user owns. Only notify once, when the user is the owner, not the
	// owners bots
	if !user.IsBot {
		//a.notifySysadminsBotOwnerDeactivated(userId)
	}

	if *a.Config().ServiceSettings.DisableBotsWhenOwnerIsDeactivated {
		//a.disableUserBots(userId)
	}

	return nil
}

func (a *App) DeactivateGuests() *model.AppError {
	userIds, err := a.Srv().Store.User().DeactivateGuests()
	if err != nil {
		return err
	}

	for _, userId := range userIds {
		if err := a.userDeactivated(userId); err != nil {
			return err
		}
	}

	//a.Srv().Store.Channel().ClearCaches()
	a.Srv().Store.User().ClearCaches()

	message := model.NewWebSocketEvent(model.WEBSOCKET_EVENT_GUESTS_DEACTIVATED, "", "", "", nil)
	a.Publish(message)

	return nil
}

func (app *App) SanitizeProfile(user *model.User, asAdmin bool) {
	options := app.Config().GetSanitizeOptions()
	if asAdmin {
		options["email"] = true
	}
	options["fullname"] = true
	options["authservice"] = true
	user.SanitizeProfile(options)
}

func (a *App) GetUsersPage(options *model.UserGetOptions, asAdmin bool) ([]*model.User, *model.AppError) {
	users, err := a.GetUsers(options)
	if err != nil {
		return nil, err
	}

	return a.sanitizeProfiles(users, asAdmin), nil
}

func (a *App) GetUsersEtag(restrictionsHash string) string {
	return fmt.Sprintf("%v.%v.%v.%v", a.Srv().Store.User().GetEtagForAllProfiles(), a.Config().PrivacySettings.ShowFullName, a.Config().PrivacySettings.ShowEmailAddress, restrictionsHash)
}

func (a *App) GetUsersInTeam(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	return a.Srv().Store.User().GetProfiles(options)
}

func (a *App) GetUsersNotInTeam(teamId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	return a.Srv().Store.User().GetProfilesNotInTeam(teamId, groupConstrained, offset, limit, viewRestrictions)
}

func (a *App) GetUsersInTeamPage(options *model.UserGetOptions, asAdmin bool) ([]*model.User, *model.AppError) {
	users, err := a.GetUsersInTeam(options)
	if err != nil {
		return nil, err
	}

	return a.sanitizeProfiles(users, asAdmin), nil
}

func (a *App) GetUsersNotInTeamPage(teamId string, groupConstrained bool, page int, perPage int, asAdmin bool, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	users, err := a.GetUsersNotInTeam(teamId, groupConstrained, page*perPage, perPage, viewRestrictions)
	if err != nil {
		return nil, err
	}

	return a.sanitizeProfiles(users, asAdmin), nil
}

func (a *App) GetUsersInTeamEtag(teamId string, restrictionsHash string) string {
	return fmt.Sprintf("%v.%v.%v.%v", a.Srv().Store.User().GetEtagForProfiles(teamId), a.Config().PrivacySettings.ShowFullName, a.Config().PrivacySettings.ShowEmailAddress, restrictionsHash)
}

func (a *App) GetUsersNotInTeamEtag(teamId string, restrictionsHash string) string {
	return fmt.Sprintf("%v.%v.%v.%v", a.Srv().Store.User().GetEtagForProfilesNotInTeam(teamId), a.Config().PrivacySettings.ShowFullName, a.Config().PrivacySettings.ShowEmailAddress, restrictionsHash)
}

func (a *App) GetUsersInChannel(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	return a.Srv().Store.User().GetProfilesInChannel(options)
}

func (a *App) GetUsersInChannelByStatus(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	return a.Srv().Store.User().GetProfilesInChannelByStatus(options)
}

func (a *App) GetUsersInChannelMap(options *model.UserGetOptions, asAdmin bool) (map[string]*model.User, *model.AppError) {
	users, err := a.GetUsersInChannel(options)
	if err != nil {
		return nil, err
	}

	userMap := make(map[string]*model.User, len(users))

	for _, user := range users {
		a.SanitizeProfile(user, asAdmin)
		userMap[user.Id] = user
	}

	return userMap, nil
}

func (a *App) GetUsersInChannelPage(options *model.UserGetOptions, asAdmin bool) ([]*model.User, *model.AppError) {
	users, err := a.GetUsersInChannel(options)
	if err != nil {
		return nil, err
	}
	return a.sanitizeProfiles(users, asAdmin), nil
}

func (a *App) GetUsersInChannelPageByStatus(options *model.UserGetOptions, asAdmin bool) ([]*model.User, *model.AppError) {
	users, err := a.GetUsersInChannelByStatus(options)
	if err != nil {
		return nil, err
	}
	return a.sanitizeProfiles(users, asAdmin), nil
}

func (a *App) GetUsersNotInChannel(teamId string, channelId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	return a.Srv().Store.User().GetProfilesNotInChannel(teamId, channelId, groupConstrained, offset, limit, viewRestrictions)
}

func (a *App) GetUsersNotInChannelMap(teamId string, channelId string, groupConstrained bool, offset int, limit int, asAdmin bool, viewRestrictions *model.ViewUsersRestrictions) (map[string]*model.User, *model.AppError) {
	users, err := a.GetUsersNotInChannel(teamId, channelId, groupConstrained, offset, limit, viewRestrictions)
	if err != nil {
		return nil, err
	}

	userMap := make(map[string]*model.User, len(users))

	for _, user := range users {
		a.SanitizeProfile(user, asAdmin)
		userMap[user.Id] = user
	}

	return userMap, nil
}

func (a *App) GetUsersNotInChannelPage(teamId string, channelId string, groupConstrained bool, page int, perPage int, asAdmin bool, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	users, err := a.GetUsersNotInChannel(teamId, channelId, groupConstrained, page*perPage, perPage, viewRestrictions)
	if err != nil {
		return nil, err
	}

	return a.sanitizeProfiles(users, asAdmin), nil
}

func (a *App) GetUsersWithoutTeamPage(options *model.UserGetOptions, asAdmin bool) ([]*model.User, *model.AppError) {
	users, err := a.GetUsersWithoutTeam(options)
	if err != nil {
		return nil, err
	}

	return a.sanitizeProfiles(users, asAdmin), nil
}

func (a *App) GetUsersWithoutTeam(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	return a.Srv().Store.User().GetProfilesWithoutTeam(options)
}

func (a *App) GetUsersByIds(userIds []string, options *store.UserGetByIdsOpts) ([]*model.User, *model.AppError) {
	allowFromCache := options.ViewRestrictions == nil

	users, err := a.Srv().Store.User().GetProfileByIds(userIds, options, allowFromCache)
	if err != nil {
		return nil, err
	}

	return a.sanitizeProfiles(users, options.IsAdmin), nil
}

func (a *App) sanitizeProfiles(users []*model.User, asAdmin bool) []*model.User {
	for _, u := range users {
		a.SanitizeProfile(u, asAdmin)
	}

	return users
}

func (a *App) GetUsers(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	return a.Srv().Store.User().GetAllProfiles(options)
}

func (a *App) VerifyUserEmail(userId, email string) *model.AppError {
	if _, err := a.Srv().Store.User().VerifyEmail(userId, email); err != nil {
		return err
	}

	a.InvalidateCacheForUser(userId)

	user, err := a.GetUser(userId)

	if err != nil {
		return err
	}

	a.sendUpdatedUserEvent(*user)

	return nil
}
