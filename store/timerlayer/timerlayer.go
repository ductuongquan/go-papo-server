// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make store-layers"
// DO NOT EDIT

package timerlayer

import (
	"context"
	timemodule "time"

	"bitbucket.org/enesyteam/papo-server/einterfaces"
	"bitbucket.org/enesyteam/papo-server/model"
	"bitbucket.org/enesyteam/papo-server/store"
)

type TimerLayer struct {
	store.Store
	Metrics                   einterfaces.MetricsInterface
	AuditStore                store.AuditStore
	AutoMessageTaskStore      store.AutoMessageTaskStore
	ClusterDiscoveryStore     store.ClusterDiscoveryStore
	CommandStore              store.CommandStore
	ComplianceStore           store.ComplianceStore
	ConversationNoteStore     store.ConversationNoteStore
	ConversationTagStore      store.ConversationTagStore
	FacebookConversationStore store.FacebookConversationStore
	FacebookPostStore         store.FacebookPostStore
	FacebookUidStore          store.FacebookUidStore
	FanpageStore              store.FanpageStore
	FanpageInitResultStore    store.FanpageInitResultStore
	FileInfoStore             store.FileInfoStore
	JobStore                  store.JobStore
	LicenseStore              store.LicenseStore
	LinkMetadataStore         store.LinkMetadataStore
	OAuthStore                store.OAuthStore
	OrderStore                store.OrderStore
	PageReplySnippetStore     store.PageReplySnippetStore
	PageTagStore              store.PageTagStore
	PluginStore               store.PluginStore
	PreferenceStore           store.PreferenceStore
	ReactionStore             store.ReactionStore
	RoleStore                 store.RoleStore
	SchemeStore               store.SchemeStore
	SessionStore              store.SessionStore
	StatusStore               store.StatusStore
	SystemStore               store.SystemStore
	TeamStore                 store.TeamStore
	TermsOfServiceStore       store.TermsOfServiceStore
	TokenStore                store.TokenStore
	UploadSessionStore        store.UploadSessionStore
	UserStore                 store.UserStore
	UserAccessTokenStore      store.UserAccessTokenStore
	UserTermsOfServiceStore   store.UserTermsOfServiceStore
	WebhookStore              store.WebhookStore
}

func (s *TimerLayer) Audit() store.AuditStore {
	return s.AuditStore
}

func (s *TimerLayer) AutoMessageTask() store.AutoMessageTaskStore {
	return s.AutoMessageTaskStore
}

func (s *TimerLayer) ClusterDiscovery() store.ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *TimerLayer) Command() store.CommandStore {
	return s.CommandStore
}

func (s *TimerLayer) Compliance() store.ComplianceStore {
	return s.ComplianceStore
}

func (s *TimerLayer) ConversationNote() store.ConversationNoteStore {
	return s.ConversationNoteStore
}

func (s *TimerLayer) ConversationTag() store.ConversationTagStore {
	return s.ConversationTagStore
}

func (s *TimerLayer) FacebookConversation() store.FacebookConversationStore {
	return s.FacebookConversationStore
}

func (s *TimerLayer) FacebookPost() store.FacebookPostStore {
	return s.FacebookPostStore
}

func (s *TimerLayer) FacebookUid() store.FacebookUidStore {
	return s.FacebookUidStore
}

func (s *TimerLayer) Fanpage() store.FanpageStore {
	return s.FanpageStore
}

func (s *TimerLayer) FanpageInitResult() store.FanpageInitResultStore {
	return s.FanpageInitResultStore
}

func (s *TimerLayer) FileInfo() store.FileInfoStore {
	return s.FileInfoStore
}

func (s *TimerLayer) Job() store.JobStore {
	return s.JobStore
}

func (s *TimerLayer) License() store.LicenseStore {
	return s.LicenseStore
}

func (s *TimerLayer) LinkMetadata() store.LinkMetadataStore {
	return s.LinkMetadataStore
}

func (s *TimerLayer) OAuth() store.OAuthStore {
	return s.OAuthStore
}

func (s *TimerLayer) Order() store.OrderStore {
	return s.OrderStore
}

func (s *TimerLayer) PageReplySnippet() store.PageReplySnippetStore {
	return s.PageReplySnippetStore
}

func (s *TimerLayer) PageTag() store.PageTagStore {
	return s.PageTagStore
}

func (s *TimerLayer) Plugin() store.PluginStore {
	return s.PluginStore
}

func (s *TimerLayer) Preference() store.PreferenceStore {
	return s.PreferenceStore
}

func (s *TimerLayer) Reaction() store.ReactionStore {
	return s.ReactionStore
}

func (s *TimerLayer) Role() store.RoleStore {
	return s.RoleStore
}

func (s *TimerLayer) Scheme() store.SchemeStore {
	return s.SchemeStore
}

func (s *TimerLayer) Session() store.SessionStore {
	return s.SessionStore
}

func (s *TimerLayer) Status() store.StatusStore {
	return s.StatusStore
}

func (s *TimerLayer) System() store.SystemStore {
	return s.SystemStore
}

func (s *TimerLayer) Team() store.TeamStore {
	return s.TeamStore
}

func (s *TimerLayer) TermsOfService() store.TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *TimerLayer) Token() store.TokenStore {
	return s.TokenStore
}

func (s *TimerLayer) UploadSession() store.UploadSessionStore {
	return s.UploadSessionStore
}

func (s *TimerLayer) User() store.UserStore {
	return s.UserStore
}

func (s *TimerLayer) UserAccessToken() store.UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *TimerLayer) UserTermsOfService() store.UserTermsOfServiceStore {
	return s.UserTermsOfServiceStore
}

func (s *TimerLayer) Webhook() store.WebhookStore {
	return s.WebhookStore
}

type TimerLayerAuditStore struct {
	store.AuditStore
	Root *TimerLayer
}

type TimerLayerAutoMessageTaskStore struct {
	store.AutoMessageTaskStore
	Root *TimerLayer
}

type TimerLayerClusterDiscoveryStore struct {
	store.ClusterDiscoveryStore
	Root *TimerLayer
}

type TimerLayerCommandStore struct {
	store.CommandStore
	Root *TimerLayer
}

type TimerLayerComplianceStore struct {
	store.ComplianceStore
	Root *TimerLayer
}

type TimerLayerConversationNoteStore struct {
	store.ConversationNoteStore
	Root *TimerLayer
}

type TimerLayerConversationTagStore struct {
	store.ConversationTagStore
	Root *TimerLayer
}

type TimerLayerFacebookConversationStore struct {
	store.FacebookConversationStore
	Root *TimerLayer
}

type TimerLayerFacebookPostStore struct {
	store.FacebookPostStore
	Root *TimerLayer
}

type TimerLayerFacebookUidStore struct {
	store.FacebookUidStore
	Root *TimerLayer
}

type TimerLayerFanpageStore struct {
	store.FanpageStore
	Root *TimerLayer
}

type TimerLayerFanpageInitResultStore struct {
	store.FanpageInitResultStore
	Root *TimerLayer
}

type TimerLayerFileInfoStore struct {
	store.FileInfoStore
	Root *TimerLayer
}

type TimerLayerJobStore struct {
	store.JobStore
	Root *TimerLayer
}

type TimerLayerLicenseStore struct {
	store.LicenseStore
	Root *TimerLayer
}

type TimerLayerLinkMetadataStore struct {
	store.LinkMetadataStore
	Root *TimerLayer
}

type TimerLayerOAuthStore struct {
	store.OAuthStore
	Root *TimerLayer
}

type TimerLayerOrderStore struct {
	store.OrderStore
	Root *TimerLayer
}

type TimerLayerPageReplySnippetStore struct {
	store.PageReplySnippetStore
	Root *TimerLayer
}

type TimerLayerPageTagStore struct {
	store.PageTagStore
	Root *TimerLayer
}

type TimerLayerPluginStore struct {
	store.PluginStore
	Root *TimerLayer
}

type TimerLayerPreferenceStore struct {
	store.PreferenceStore
	Root *TimerLayer
}

type TimerLayerReactionStore struct {
	store.ReactionStore
	Root *TimerLayer
}

type TimerLayerRoleStore struct {
	store.RoleStore
	Root *TimerLayer
}

type TimerLayerSchemeStore struct {
	store.SchemeStore
	Root *TimerLayer
}

type TimerLayerSessionStore struct {
	store.SessionStore
	Root *TimerLayer
}

type TimerLayerStatusStore struct {
	store.StatusStore
	Root *TimerLayer
}

type TimerLayerSystemStore struct {
	store.SystemStore
	Root *TimerLayer
}

type TimerLayerTeamStore struct {
	store.TeamStore
	Root *TimerLayer
}

type TimerLayerTermsOfServiceStore struct {
	store.TermsOfServiceStore
	Root *TimerLayer
}

type TimerLayerTokenStore struct {
	store.TokenStore
	Root *TimerLayer
}

type TimerLayerUploadSessionStore struct {
	store.UploadSessionStore
	Root *TimerLayer
}

type TimerLayerUserStore struct {
	store.UserStore
	Root *TimerLayer
}

type TimerLayerUserAccessTokenStore struct {
	store.UserAccessTokenStore
	Root *TimerLayer
}

type TimerLayerUserTermsOfServiceStore struct {
	store.UserTermsOfServiceStore
	Root *TimerLayer
}

type TimerLayerWebhookStore struct {
	store.WebhookStore
	Root *TimerLayer
}

func (s *TimerLayerAuditStore) Get(user_id string, offset int, limit int) (model.Audits, error) {
	start := timemodule.Now()

	result, err := s.AuditStore.Get(user_id, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAuditStore) PermanentDeleteByUser(userId string) error {
	start := timemodule.Now()

	err := s.AuditStore.PermanentDeleteByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerAuditStore) Save(audit *model.Audit) error {
	start := timemodule.Now()

	err := s.AuditStore.Save(audit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerAutoMessageTaskStore) Delete(taskId string) StoreChannel {
	start := timemodule.Now()

	result := s.AutoMessageTaskStore.Delete(taskId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AutoMessageTaskStore.Delete", success, elapsed)
	}
	return result
}

func (s *TimerLayerAutoMessageTaskStore) GetByPageId(pageId string) StoreChannel {
	start := timemodule.Now()

	result := s.AutoMessageTaskStore.GetByPageId(pageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AutoMessageTaskStore.GetByPageId", success, elapsed)
	}
	return result
}

func (s *TimerLayerAutoMessageTaskStore) Pause(taskId string) StoreChannel {
	start := timemodule.Now()

	result := s.AutoMessageTaskStore.Pause(taskId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AutoMessageTaskStore.Pause", success, elapsed)
	}
	return result
}

func (s *TimerLayerAutoMessageTaskStore) Save(messageTask *model.AutoMessageTask) StoreChannel {
	start := timemodule.Now()

	result := s.AutoMessageTaskStore.Save(messageTask)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AutoMessageTaskStore.Save", success, elapsed)
	}
	return result
}

func (s *TimerLayerAutoMessageTaskStore) Start(taskId string) StoreChannel {
	start := timemodule.Now()

	result := s.AutoMessageTaskStore.Start(taskId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AutoMessageTaskStore.Start", success, elapsed)
	}
	return result
}

func (s *TimerLayerAutoMessageTaskStore) Update(messageTask *model.AutoMessageTask) StoreChannel {
	start := timemodule.Now()

	result := s.AutoMessageTaskStore.Update(messageTask)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AutoMessageTaskStore.Update", success, elapsed)
	}
	return result
}

func (s *TimerLayerClusterDiscoveryStore) Cleanup() error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Cleanup", success, elapsed)
	}
	return err
}

func (s *TimerLayerClusterDiscoveryStore) Delete(discovery *model.ClusterDiscovery) (bool, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.Delete(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Exists(discovery *model.ClusterDiscovery) (bool, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.Exists(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Exists", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) ([]*model.ClusterDiscovery, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Save(discovery *model.ClusterDiscovery) error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.Save(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerClusterDiscoveryStore) SetLastPingAt(discovery *model.ClusterDiscovery) error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.SetLastPingAt(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.SetLastPingAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerCommandStore) AnalyticsCommandCount(teamId string) (int64, error) {
	start := timemodule.Now()

	result, err := s.CommandStore.AnalyticsCommandCount(teamId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.AnalyticsCommandCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandStore) Delete(commandId string, time int64) error {
	start := timemodule.Now()

	err := s.CommandStore.Delete(commandId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerCommandStore) Get(id string) (*model.Command, error) {
	start := timemodule.Now()

	result, err := s.CommandStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandStore) GetByTeam(teamId string) ([]*model.Command, error) {
	start := timemodule.Now()

	result, err := s.CommandStore.GetByTeam(teamId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.GetByTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandStore) GetByTrigger(teamId string, trigger string) (*model.Command, error) {
	start := timemodule.Now()

	result, err := s.CommandStore.GetByTrigger(teamId, trigger)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.GetByTrigger", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandStore) PermanentDeleteByTeam(teamId string) error {
	start := timemodule.Now()

	err := s.CommandStore.PermanentDeleteByTeam(teamId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.PermanentDeleteByTeam", success, elapsed)
	}
	return err
}

func (s *TimerLayerCommandStore) PermanentDeleteByUser(userId string) error {
	start := timemodule.Now()

	err := s.CommandStore.PermanentDeleteByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerCommandStore) Save(webhook *model.Command) (*model.Command, error) {
	start := timemodule.Now()

	result, err := s.CommandStore.Save(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCommandStore) Update(hook *model.Command) (*model.Command, error) {
	start := timemodule.Now()

	result, err := s.CommandStore.Update(hook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CommandStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) Get(id string) (*model.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) GetAll(offset int, limit int) (model.Compliances, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.GetAll(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) Save(compliance *model.Compliance) (*model.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Save(compliance)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) Update(compliance *model.Compliance) (*model.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Update(compliance)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerConversationNoteStore) Delete(id string) StoreChannel {
	start := timemodule.Now()

	result := s.ConversationNoteStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ConversationNoteStore.Delete", success, elapsed)
	}
	return result
}

func (s *TimerLayerConversationNoteStore) Get(id string) StoreChannel {
	start := timemodule.Now()

	result := s.ConversationNoteStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ConversationNoteStore.Get", success, elapsed)
	}
	return result
}

func (s *TimerLayerConversationNoteStore) GetConversationNotes(conversationId string) StoreChannel {
	start := timemodule.Now()

	result := s.ConversationNoteStore.GetConversationNotes(conversationId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ConversationNoteStore.GetConversationNotes", success, elapsed)
	}
	return result
}

func (s *TimerLayerConversationNoteStore) Save(tag *model.ConversationNote) StoreChannel {
	start := timemodule.Now()

	result := s.ConversationNoteStore.Save(tag)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ConversationNoteStore.Save", success, elapsed)
	}
	return result
}

func (s *TimerLayerConversationNoteStore) Update(note *model.ConversationNote) StoreChannel {
	start := timemodule.Now()

	result := s.ConversationNoteStore.Update(note)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ConversationNoteStore.Update", success, elapsed)
	}
	return result
}

func (s *TimerLayerConversationTagStore) Delete(id string) StoreChannel {
	start := timemodule.Now()

	result := s.ConversationTagStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ConversationTagStore.Delete", success, elapsed)
	}
	return result
}

func (s *TimerLayerConversationTagStore) Get(id string) StoreChannel {
	start := timemodule.Now()

	result := s.ConversationTagStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ConversationTagStore.Get", success, elapsed)
	}
	return result
}

func (s *TimerLayerConversationTagStore) GetConversationTags(conversationId string) StoreChannel {
	start := timemodule.Now()

	result := s.ConversationTagStore.GetConversationTags(conversationId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ConversationTagStore.GetConversationTags", success, elapsed)
	}
	return result
}

func (s *TimerLayerConversationTagStore) Save(tag *model.ConversationTag) StoreChannel {
	start := timemodule.Now()

	result := s.ConversationTagStore.Save(tag)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ConversationTagStore.Save", success, elapsed)
	}
	return result
}

func (s *TimerLayerConversationTagStore) SaveOrRemove(tag *model.ConversationTag) StoreChannel {
	start := timemodule.Now()

	result := s.ConversationTagStore.SaveOrRemove(tag)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ConversationTagStore.SaveOrRemove", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) AddImage(image *model.FacebookAttachmentImage) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.AddImage(image)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.AddImage", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) AddMessage(message *model.FacebookConversationMessage, shouldUpdateConversation bool, isFromPage bool) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.AddMessage(message, shouldUpdateConversation, isFromPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.AddMessage", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) AnalyticsConversationCountsByDay(pageId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.AnalyticsConversationCountsByDay(pageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.AnalyticsConversationCountsByDay", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) DeleteCommentByCommentId(commentId string, appScopedUserId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.DeleteCommentByCommentId(commentId, appScopedUserId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.DeleteCommentByCommentId", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) Get(conversationId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.Get(conversationId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.Get", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) GetConversationById(id string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.GetConversationById(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.GetConversationById", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) GetConversations(pageIds string, offset int, limit int) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.GetConversations(pageIds, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.GetConversations", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) GetFacebookAttachmentByIds(userIds []string, allowFromCache bool) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.GetFacebookAttachmentByIds(userIds, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.GetFacebookAttachmentByIds", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) GetMessage(messageId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.GetMessage(messageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.GetMessage", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) GetMessagesByConversationId(conversationId string, offset int, limit int) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.GetMessagesByConversationId(conversationId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.GetMessagesByConversationId", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) GetPageConversationBySenderId(pageId string, senderId string, conversationType string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.GetPageConversationBySenderId(pageId, senderId, conversationType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.GetPageConversationBySenderId", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) GetPageMessageByMid(pageId string, mid string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.GetPageMessageByMid(pageId, mid)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.GetPageMessageByMid", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) InsertConversationFromCommentIfNeed(parentId string, commentId string, pageId string, postId string, userId string, time string, message string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.InsertConversationFromCommentIfNeed(parentId, commentId, pageId, postId, userId, time, message)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.InsertConversationFromCommentIfNeed", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) OverwriteMessage(message *model.FacebookConversationMessage) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.OverwriteMessage(message)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.OverwriteMessage", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) Save(conversation *model.FacebookConversation) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.Save(conversation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.Save", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) Search(term string, pageIds string, offset int, limit int) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.Search(term, pageIds, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.Search", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) UpdateCommentByCommentId(commentId string, newText string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.UpdateCommentByCommentId(commentId, newText)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.UpdateCommentByCommentId", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) UpdateConversation(conversationId string, snippet string, isFromPage bool, updatedTime string, unreadCount int, lastUserMessageAt string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.UpdateConversation(conversationId, snippet, isFromPage, updatedTime, unreadCount, lastUserMessageAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.UpdateConversation", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) UpdateConversationUnread(conversationId string, isFromPage bool, unreadCount int, lastUserMessageAt string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.UpdateConversationUnread(conversationId, isFromPage, unreadCount, lastUserMessageAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.UpdateConversationUnread", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) UpdateLatestTime(conversationId string, time string, commentId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.UpdateLatestTime(conversationId, time, commentId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.UpdateLatestTime", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) UpdateMessageSent(messageId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.UpdateMessageSent(messageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.UpdateMessageSent", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) UpdatePageScopeId(conversationId string, pageScopeId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.UpdatePageScopeId(conversationId, pageScopeId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.UpdatePageScopeId", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) UpdateReadWatermark(conversationId string, pageId string, timestamp int64) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.UpdateReadWatermark(conversationId, pageId, timestamp)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.UpdateReadWatermark", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) UpdateSeen(id string, pageId string, userId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.UpdateSeen(id, pageId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.UpdateSeen", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) UpdateUnSeen(id string, pageId string, userId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.UpdateUnSeen(id, pageId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.UpdateUnSeen", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookConversationStore) UpsertCommentConversation(conversation *model.FacebookConversation) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookConversationStore.UpsertCommentConversation(conversation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookConversationStore.UpsertCommentConversation", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookPostStore) Get(postId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookPostStore.Get(postId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookPostStore.Get", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookPostStore) GetPagePosts(pageId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookPostStore.GetPagePosts(pageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookPostStore.GetPagePosts", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookPostStore) Save(post *model.FacebookPost) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookPostStore.Save(post)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookPostStore.Save", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookUidStore) Get(id string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookUidStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookUidStore.Get", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookUidStore) GetByIds(userIds []string, allowFromCache bool) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookUidStore.GetByIds(userIds, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookUidStore.GetByIds", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookUidStore) UpdatePageId(id string, pageId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookUidStore.UpdatePageId(id, pageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookUidStore.UpdatePageId", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookUidStore) UpdatePageScopeId(id string, pageScopeId string) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookUidStore.UpdatePageScopeId(id, pageScopeId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookUidStore.UpdatePageScopeId", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookUidStore) UpsertFromFbUser(fbUser facebookgraph.FacebookUser) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookUidStore.UpsertFromFbUser(fbUser)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookUidStore.UpsertFromFbUser", success, elapsed)
	}
	return result
}

func (s *TimerLayerFacebookUidStore) UpsertFromMap(data map[string]interface{}) StoreChannel {
	start := timemodule.Now()

	result := s.FacebookUidStore.UpsertFromMap(data)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FacebookUidStore.UpsertFromMap", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) Get(fanpageId string) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.Get(fanpageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.Get", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) GetAllPageMembersForUser(userId string, allowFromCache bool, includeDeleted bool) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.GetAllPageMembersForUser(userId, allowFromCache, includeDeleted)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.GetAllPageMembersForUser", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) GetFanpageByPageID(pageId string) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.GetFanpageByPageID(pageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.GetFanpageByPageID", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) GetFanpagesByUserId(userId string) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.GetFanpagesByUserId(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.GetFanpagesByUserId", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) GetMember(teamId string, userId string) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.GetMember(teamId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.GetMember", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) GetMemberByPageId(pageId string, userId string) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.GetMemberByPageId(pageId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.GetMemberByPageId", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) GetOneFanPageMember(fanpageId string) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.GetOneFanPageMember(fanpageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.GetOneFanPageMember", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) Save(fanpage *model.Fanpage) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.Save(fanpage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.Save", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) SaveFanPageMember(member *model.FanpageMember) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.SaveFanPageMember(member)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.SaveFanPageMember", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) Update(newPage *model.Fanpage, oldPage *model.Fanpage) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.Update(newPage, oldPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.Update", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) UpdateLastViewedAt(pageIds []string, userId string) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.UpdateLastViewedAt(pageIds, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.UpdateLastViewedAt", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) UpdatePagesStatus(pageIds *model.LoadPagesInput, status string) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.UpdatePagesStatus(pageIds, status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.UpdatePagesStatus", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) UpdateStatus(pageId string, status string) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.UpdateStatus(pageId, status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.UpdateStatus", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageStore) ValidatePagesBeforeInit(pageIds *model.LoadPagesInput) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageStore.ValidatePagesBeforeInit(pageIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageStore.ValidatePagesBeforeInit", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageInitResultStore) Save(job *model.FanpageInitResult) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageInitResultStore.Save(job)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageInitResultStore.Save", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageInitResultStore) UpdateCommentCount(r *model.FanpageInitResult, newCount int64) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageInitResultStore.UpdateCommentCount(r, newCount)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageInitResultStore.UpdateCommentCount", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageInitResultStore) UpdateConversationCount(r *model.FanpageInitResult, newCount int64) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageInitResultStore.UpdateConversationCount(r, newCount)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageInitResultStore.UpdateConversationCount", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageInitResultStore) UpdateEndAt(r *model.FanpageInitResult, endAt int64) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageInitResultStore.UpdateEndAt(r, endAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageInitResultStore.UpdateEndAt", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageInitResultStore) UpdateMessageCount(r *model.FanpageInitResult, newCount int64) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageInitResultStore.UpdateMessageCount(r, newCount)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageInitResultStore.UpdateMessageCount", success, elapsed)
	}
	return result
}

func (s *TimerLayerFanpageInitResultStore) UpdatePostCount(r *model.FanpageInitResult, newCount int64) StoreChannel {
	start := timemodule.Now()

	result := s.FanpageInitResultStore.UpdatePostCount(r, newCount)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FanpageInitResultStore.UpdatePostCount", success, elapsed)
	}
	return result
}

func (s *TimerLayerFileInfoStore) AttachToMessage(fileId string, messageId string, creatorId string) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.AttachToMessage(fileId, messageId, creatorId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.AttachToMessage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) AttachToPost(fileId string, postId string, creatorId string) error {
	start := timemodule.Now()

	err := s.FileInfoStore.AttachToPost(fileId, postId, creatorId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.AttachToPost", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) ClearCaches() {
	start := timemodule.Now()

	s.FileInfoStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) DeleteForPost(postId string) (string, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.DeleteForPost(postId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.DeleteForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) Get(id string) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetByPath(path string) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetByPath(path)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetByPath", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetForPage(pageId string, readFromMaster bool, allowFromCache bool, offset int, limit int) ([]*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetForPage(pageId, readFromMaster, allowFromCache, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetForPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetForUser(userId string) ([]*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetWithOptions(page int, perPage int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetWithOptions(page, perPage, opt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) InvalidateFileInfosForPageCache(pageId string) {
	start := timemodule.Now()

	s.FileInfoStore.InvalidateFileInfosForPageCache(pageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.InvalidateFileInfosForPageCache", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) PermanentDelete(fileId string) error {
	start := timemodule.Now()

	err := s.FileInfoStore.PermanentDelete(fileId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteByUser(userId string) (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.PermanentDeleteByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) Save(info *model.FileInfo) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.Save(info)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) Upsert(info *model.FileInfo) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.Upsert(info)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Delete(id string) (string, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Get(id string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByStatus(status string) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByStatus(status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByType(jobType string) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByType(jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByTypePage(jobType string, offset int, limit int) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByTypePage(jobType, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByTypePage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllPage(offset int, limit int) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllPage(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetCountByStatusAndType(status string, jobType string) (int64, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetCountByStatusAndType(status, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetCountByStatusAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetNewestJobByStatusAndType(status string, jobType string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetNewestJobByStatusAndType(status, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetNewestJobByStatusAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetNewestJobByStatusesAndType(statuses []string, jobType string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetNewestJobByStatusesAndType(statuses, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetNewestJobByStatusesAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Save(job *model.Job) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Save(job)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateOptimistically(job *model.Job, currentStatus string) (bool, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateOptimistically(job, currentStatus)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateOptimistically", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateStatus(id string, status string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateStatus(id, status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateStatusOptimistically(id string, currentStatus string, newStatus string) (bool, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatusOptimistically", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerLicenseStore) Get(id string) (*model.LicenseRecord, error) {
	start := timemodule.Now()

	result, err := s.LicenseStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LicenseStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerLicenseStore) Save(license *model.LicenseRecord) (*model.LicenseRecord, error) {
	start := timemodule.Now()

	result, err := s.LicenseStore.Save(license)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LicenseStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerLinkMetadataStore) Get(url string, timestamp int64) (*model.LinkMetadata, error) {
	start := timemodule.Now()

	result, err := s.LinkMetadataStore.Get(url, timestamp)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LinkMetadataStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerLinkMetadataStore) Save(linkMetadata *model.LinkMetadata) (*model.LinkMetadata, error) {
	start := timemodule.Now()

	result, err := s.LinkMetadataStore.Save(linkMetadata)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("LinkMetadataStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) DeleteApp(id string) error {
	start := timemodule.Now()

	err := s.OAuthStore.DeleteApp(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.DeleteApp", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) GetAccessData(token string) (*model.AccessData, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.GetAccessData(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAccessData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetAccessDataByRefreshToken(token string) (*model.AccessData, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.GetAccessDataByRefreshToken(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAccessDataByRefreshToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetAccessDataByUserForApp(userId string, clientId string) ([]*model.AccessData, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.GetAccessDataByUserForApp(userId, clientId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAccessDataByUserForApp", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetApp(id string) (*model.OAuthApp, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.GetApp(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetApp", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetAppByUser(userId string, offset int, limit int) ([]*model.OAuthApp, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.GetAppByUser(userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAppByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetApps(offset int, limit int) ([]*model.OAuthApp, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.GetApps(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetApps", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetAuthData(code string) (*model.AuthData, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.GetAuthData(code)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAuthData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetAuthorizedApps(userId string, offset int, limit int) ([]*model.OAuthApp, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.GetAuthorizedApps(userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetAuthorizedApps", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) GetPreviousAccessData(userId string, clientId string) (*model.AccessData, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.GetPreviousAccessData(userId, clientId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.GetPreviousAccessData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) PermanentDeleteAuthDataByUser(userId string) error {
	start := timemodule.Now()

	err := s.OAuthStore.PermanentDeleteAuthDataByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.PermanentDeleteAuthDataByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) RemoveAccessData(token string) error {
	start := timemodule.Now()

	err := s.OAuthStore.RemoveAccessData(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAccessData", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) RemoveAllAccessData() error {
	start := timemodule.Now()

	err := s.OAuthStore.RemoveAllAccessData()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAllAccessData", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) RemoveAuthData(code string) error {
	start := timemodule.Now()

	err := s.OAuthStore.RemoveAuthData(code)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.RemoveAuthData", success, elapsed)
	}
	return err
}

func (s *TimerLayerOAuthStore) SaveAccessData(accessData *model.AccessData) (*model.AccessData, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.SaveAccessData(accessData)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.SaveAccessData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) SaveApp(app *model.OAuthApp) (*model.OAuthApp, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.SaveApp(app)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.SaveApp", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) SaveAuthData(authData *model.AuthData) (*model.AuthData, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.SaveAuthData(authData)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.SaveAuthData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) UpdateAccessData(accessData *model.AccessData) (*model.AccessData, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.UpdateAccessData(accessData)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.UpdateAccessData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOAuthStore) UpdateApp(app *model.OAuthApp) (*model.OAuthApp, error) {
	start := timemodule.Now()

	result, err := s.OAuthStore.UpdateApp(app)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OAuthStore.UpdateApp", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) GetOrders(limit int, offset int) StoreChannel {
	start := timemodule.Now()

	result := s.OrderStore.GetOrders(limit, offset)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.GetOrders", success, elapsed)
	}
	return result
}

func (s *TimerLayerOrderStore) Save(order *model.Order) StoreChannel {
	start := timemodule.Now()

	result := s.OrderStore.Save(order)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.Save", success, elapsed)
	}
	return result
}

func (s *TimerLayerPageReplySnippetStore) CheckDuplicate(pageId string, trigger string) StoreChannel {
	start := timemodule.Now()

	result := s.PageReplySnippetStore.CheckDuplicate(pageId, trigger)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageReplySnippetStore.CheckDuplicate", success, elapsed)
	}
	return result
}

func (s *TimerLayerPageReplySnippetStore) GetByPageId(pageId string) StoreChannel {
	start := timemodule.Now()

	result := s.PageReplySnippetStore.GetByPageId(pageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageReplySnippetStore.GetByPageId", success, elapsed)
	}
	return result
}

func (s *TimerLayerPageReplySnippetStore) Save(snippet *model.ReplySnippet) StoreChannel {
	start := timemodule.Now()

	result := s.PageReplySnippetStore.Save(snippet)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageReplySnippetStore.Save", success, elapsed)
	}
	return result
}

func (s *TimerLayerPageReplySnippetStore) Update(snippet *model.ReplySnippet) StoreChannel {
	start := timemodule.Now()

	result := s.PageReplySnippetStore.Update(snippet)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageReplySnippetStore.Update", success, elapsed)
	}
	return result
}

func (s *TimerLayerPageTagStore) Delete(id string) StoreChannel {
	start := timemodule.Now()

	result := s.PageTagStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageTagStore.Delete", success, elapsed)
	}
	return result
}

func (s *TimerLayerPageTagStore) Get(id string) StoreChannel {
	start := timemodule.Now()

	result := s.PageTagStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageTagStore.Get", success, elapsed)
	}
	return result
}

func (s *TimerLayerPageTagStore) GetPageTags(pageId string) StoreChannel {
	start := timemodule.Now()

	result := s.PageTagStore.GetPageTags(pageId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageTagStore.GetPageTags", success, elapsed)
	}
	return result
}

func (s *TimerLayerPageTagStore) Save(tag *model.PageTag) StoreChannel {
	start := timemodule.Now()

	result := s.PageTagStore.Save(tag)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageTagStore.Save", success, elapsed)
	}
	return result
}

func (s *TimerLayerPageTagStore) Update(tag *model.PageTag) StoreChannel {
	start := timemodule.Now()

	result := s.PageTagStore.Update(tag)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageTagStore.Update", success, elapsed)
	}
	return result
}

func (s *TimerLayerPluginStore) CompareAndDelete(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.CompareAndDelete(keyVal, oldValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.CompareAndDelete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) CompareAndSet(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.CompareAndSet(keyVal, oldValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.CompareAndSet", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) Delete(pluginId string, key string) error {
	start := timemodule.Now()

	err := s.PluginStore.Delete(pluginId, key)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) DeleteAllExpired() error {
	start := timemodule.Now()

	err := s.PluginStore.DeleteAllExpired()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.DeleteAllExpired", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) DeleteAllForPlugin(PluginId string) error {
	start := timemodule.Now()

	err := s.PluginStore.DeleteAllForPlugin(PluginId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.DeleteAllForPlugin", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) Get(pluginId string, key string) (*model.PluginKeyValue, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.Get(pluginId, key)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) List(pluginId string, page int, perPage int) ([]string, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.List(pluginId, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.List", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) SaveOrUpdate(keyVal *model.PluginKeyValue) (*model.PluginKeyValue, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.SaveOrUpdate(keyVal)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.SaveOrUpdate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) SetWithOptions(pluginId string, key string, value []byte, options model.PluginKVSetOptions) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.SetWithOptions(pluginId, key, value, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.SetWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.CleanupFlagsBatch(limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.CleanupFlagsBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) Delete(userId string, category string, name string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.Delete(userId, category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteCategory(userId string, category string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.DeleteCategory(userId, category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategory", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteCategoryAndName(category string, name string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.DeleteCategoryAndName(category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategoryAndName", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) Get(userId string, category string, name string) (*model.Preference, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.Get(userId, category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetAll(userId string) (model.Preferences, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.GetAll(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetCategory(userId string, category string) (model.Preferences, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.GetCategory(userId, category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetCategory", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) PermanentDeleteByUser(userId string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.PermanentDeleteByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) Save(preferences *model.Preferences) error {
	start := timemodule.Now()

	err := s.PreferenceStore.Save(preferences)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerReactionStore) BulkGetForPosts(postIds []string) ([]*model.Reaction, error) {
	start := timemodule.Now()

	result, err := s.ReactionStore.BulkGetForPosts(postIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.BulkGetForPosts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) Delete(reaction *model.Reaction) (*model.Reaction, error) {
	start := timemodule.Now()

	result, err := s.ReactionStore.Delete(reaction)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) DeleteAllWithEmojiName(emojiName string) error {
	start := timemodule.Now()

	err := s.ReactionStore.DeleteAllWithEmojiName(emojiName)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.DeleteAllWithEmojiName", success, elapsed)
	}
	return err
}

func (s *TimerLayerReactionStore) GetForPost(postId string, allowFromCache bool) ([]*model.Reaction, error) {
	start := timemodule.Now()

	result, err := s.ReactionStore.GetForPost(postId, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.GetForPost", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := timemodule.Now()

	result, err := s.ReactionStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.PermanentDeleteBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerReactionStore) Save(reaction *model.Reaction) (*model.Reaction, error) {
	start := timemodule.Now()

	result, err := s.ReactionStore.Save(reaction)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ReactionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) Delete(roleId string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Delete(roleId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) Get(roleId string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Get(roleId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetAll() ([]*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetByName(name string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetByNames(names []string) ([]*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetByNames(names)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByNames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) PermanentDeleteAll() error {
	start := timemodule.Now()

	err := s.RoleStore.PermanentDeleteAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.PermanentDeleteAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerRoleStore) Save(role *model.Role) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Save(role)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) CountByScope(scope string) (int64, error) {
	start := timemodule.Now()

	result, err := s.SchemeStore.CountByScope(scope)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.CountByScope", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) CountWithoutPermission(scope string, permissionID string, roleScope model.RoleScope, roleType model.RoleType) (int64, error) {
	start := timemodule.Now()

	result, err := s.SchemeStore.CountWithoutPermission(scope, permissionID, roleScope, roleType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.CountWithoutPermission", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) Delete(schemeId string) (*model.Scheme, error) {
	start := timemodule.Now()

	result, err := s.SchemeStore.Delete(schemeId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) Get(schemeId string) (*model.Scheme, error) {
	start := timemodule.Now()

	result, err := s.SchemeStore.Get(schemeId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) GetAllPage(scope string, offset int, limit int) ([]*model.Scheme, error) {
	start := timemodule.Now()

	result, err := s.SchemeStore.GetAllPage(scope, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.GetAllPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) GetByName(schemeName string) (*model.Scheme, error) {
	start := timemodule.Now()

	result, err := s.SchemeStore.GetByName(schemeName)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSchemeStore) PermanentDeleteAll() error {
	start := timemodule.Now()

	err := s.SchemeStore.PermanentDeleteAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.PermanentDeleteAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerSchemeStore) Save(scheme *model.Scheme) (*model.Scheme, error) {
	start := timemodule.Now()

	result, err := s.SchemeStore.Save(scheme)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SchemeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) AnalyticsSessionCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.AnalyticsSessionCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.AnalyticsSessionCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) {
	start := timemodule.Now()

	s.SessionStore.Cleanup(expiryTime, batchSize)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerSessionStore) Get(sessionIdOrToken string) (*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.Get(sessionIdOrToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessions(userId string) ([]*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessions(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) ([]*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsExpired", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessionsWithActiveDeviceIds(userId string) ([]*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessionsWithActiveDeviceIds(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsWithActiveDeviceIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) PermanentDeleteSessionsByUser(teamId string) error {
	start := timemodule.Now()

	err := s.SessionStore.PermanentDeleteSessionsByUser(teamId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.PermanentDeleteSessionsByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Remove(sessionIdOrToken string) error {
	start := timemodule.Now()

	err := s.SessionStore.Remove(sessionIdOrToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Remove", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) RemoveAllSessions() error {
	start := timemodule.Now()

	err := s.SessionStore.RemoveAllSessions()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.RemoveAllSessions", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Save(session *model.Session) (*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.Save(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) UpdateDeviceId(id string, deviceId string, expiresAt int64) (string, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.UpdateDeviceId(id, deviceId, expiresAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateDeviceId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) UpdateExpiredNotify(sessionid string, notified bool) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateExpiredNotify(sessionid, notified)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateExpiredNotify", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateExpiresAt(sessionId string, time int64) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateExpiresAt(sessionId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateExpiresAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateLastActivityAt(sessionId string, time int64) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateLastActivityAt(sessionId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateLastActivityAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateProps(session *model.Session) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateProps(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateProps", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateRoles(userId string, roles string) (string, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.UpdateRoles(userId, roles)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateRoles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) Get(userId string) (*model.Status, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.Get(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) GetByIds(userIds []string) ([]*model.Status, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.GetByIds(userIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) GetTotalActiveUsersCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.GetTotalActiveUsersCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetTotalActiveUsersCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) ResetAll() error {
	start := timemodule.Now()

	err := s.StatusStore.ResetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.ResetAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerStatusStore) SaveOrUpdate(status *model.Status) error {
	start := timemodule.Now()

	err := s.StatusStore.SaveOrUpdate(status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.SaveOrUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerStatusStore) UpdateLastActivityAt(userId string, lastActivityAt int64) error {
	start := timemodule.Now()

	err := s.StatusStore.UpdateLastActivityAt(userId, lastActivityAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.UpdateLastActivityAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) Get() (model.StringMap, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.Get()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) GetByName(name string) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) InsertIfExists(system *model.System) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.InsertIfExists(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.InsertIfExists", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) PermanentDeleteByName(name string) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.PermanentDeleteByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.PermanentDeleteByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) Save(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.Save(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) SaveOrUpdate(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.SaveOrUpdate(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.SaveOrUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) SaveOrUpdateWithWarnMetricHandling(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.SaveOrUpdateWithWarnMetricHandling(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.SaveOrUpdateWithWarnMetricHandling", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) Update(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.Update(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) AnalyticsGetTeamCountForScheme(schemeId string) (int64, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.AnalyticsGetTeamCountForScheme(schemeId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.AnalyticsGetTeamCountForScheme", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) AnalyticsPrivateTeamCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.AnalyticsPrivateTeamCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.AnalyticsPrivateTeamCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) AnalyticsPublicTeamCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.AnalyticsPublicTeamCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.AnalyticsPublicTeamCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) AnalyticsTeamCount(includeDeleted bool) (int64, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.AnalyticsTeamCount(includeDeleted)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.AnalyticsTeamCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) ClearAllCustomRoleAssignments() error {
	start := timemodule.Now()

	err := s.TeamStore.ClearAllCustomRoleAssignments()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) ClearCaches() {
	start := timemodule.Now()

	s.TeamStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerTeamStore) Get(id string) (*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetActiveMemberCount(teamId string, restrictions *model.ViewUsersRestrictions) (int64, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetActiveMemberCount(teamId, restrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetActiveMemberCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAll() ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllForExportAfter(limit int, afterId string) ([]*model.TeamForExport, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetAllForExportAfter(limit, afterId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllForExportAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllPage(offset int, limit int) ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetAllPage(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllPrivateTeamListing() ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetAllPrivateTeamListing()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllPrivateTeamListing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllPrivateTeamPageListing(offset int, limit int) ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetAllPrivateTeamPageListing(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllPrivateTeamPageListing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllPublicTeamPageListing(offset int, limit int) ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetAllPublicTeamPageListing(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllPublicTeamPageListing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllTeamListing() ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetAllTeamListing()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllTeamListing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetAllTeamPageListing(offset int, limit int) ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetAllTeamPageListing(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetAllTeamPageListing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetByInviteId(inviteId string) (*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetByInviteId(inviteId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetByInviteId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetByName(name string) (*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetByNames(name []string) ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetByNames(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetByNames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetChannelUnreadsForAllTeams(excludeTeamId string, userId string) ([]*model.ChannelUnread, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetChannelUnreadsForAllTeams(excludeTeamId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetChannelUnreadsForAllTeams", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetChannelUnreadsForTeam(teamId string, userId string) ([]*model.ChannelUnread, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetChannelUnreadsForTeam(teamId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetChannelUnreadsForTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetMember(teamId string, userId string) (*model.TeamMember, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetMember(teamId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetMembers(teamId string, offset int, limit int, teamMembersGetOptions *model.TeamMembersGetOptions) ([]*model.TeamMember, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetMembers(teamId, offset, limit, teamMembersGetOptions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetMembersByIds(teamId string, userIds []string, restrictions *model.ViewUsersRestrictions) ([]*model.TeamMember, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetMembersByIds(teamId, userIds, restrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetMembersByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTeamMembersForExport(userId string) ([]*model.TeamMemberForExport, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetTeamMembersForExport(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTeamMembersForExport", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTeamsByScheme(schemeId string, offset int, limit int) ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetTeamsByScheme(schemeId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTeamsByScheme", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTeamsByUserId(userId string) ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetTeamsByUserId(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTeamsByUserId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTeamsForUser(userId string) ([]*model.TeamMember, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetTeamsForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTeamsForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTeamsForUserWithPagination(userId string, page int, perPage int) ([]*model.TeamMember, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetTeamsForUserWithPagination(userId, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTeamsForUserWithPagination", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetTotalMemberCount(teamId string, restrictions *model.ViewUsersRestrictions) (int64, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetTotalMemberCount(teamId, restrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetTotalMemberCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GetUserTeamIds(userId string, allowFromCache bool) ([]string, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GetUserTeamIds(userId, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GetUserTeamIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) GroupSyncedTeamCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.GroupSyncedTeamCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.GroupSyncedTeamCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) InvalidateAllTeamIdsForUser(userId string) {
	start := timemodule.Now()

	s.TeamStore.InvalidateAllTeamIdsForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.InvalidateAllTeamIdsForUser", success, elapsed)
	}
}

func (s *TimerLayerTeamStore) MigrateTeamMembers(fromTeamId string, fromUserId string) (map[string]string, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.MigrateTeamMembers(fromTeamId, fromUserId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.MigrateTeamMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) PermanentDelete(teamId string) error {
	start := timemodule.Now()

	err := s.TeamStore.PermanentDelete(teamId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) RemoveAllMembersByTeam(teamId string) error {
	start := timemodule.Now()

	err := s.TeamStore.RemoveAllMembersByTeam(teamId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.RemoveAllMembersByTeam", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) RemoveAllMembersByUser(userId string) error {
	start := timemodule.Now()

	err := s.TeamStore.RemoveAllMembersByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.RemoveAllMembersByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) RemoveMember(teamId string, userId string) error {
	start := timemodule.Now()

	err := s.TeamStore.RemoveMember(teamId, userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.RemoveMember", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) RemoveMembers(teamId string, userIds []string) error {
	start := timemodule.Now()

	err := s.TeamStore.RemoveMembers(teamId, userIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.RemoveMembers", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) ResetAllTeamSchemes() error {
	start := timemodule.Now()

	err := s.TeamStore.ResetAllTeamSchemes()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.ResetAllTeamSchemes", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) Save(team *model.Team) (*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.Save(team)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) SaveMember(member *model.TeamMember, maxUsersPerTeam int) (*model.TeamMember, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.SaveMember(member, maxUsersPerTeam)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SaveMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) SaveMultipleMembers(members []*model.TeamMember, maxUsersPerTeam int) ([]*model.TeamMember, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.SaveMultipleMembers(members, maxUsersPerTeam)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SaveMultipleMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) SearchAll(term string, opts *model.TeamSearch) ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.SearchAll(term, opts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SearchAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) SearchAllPaged(term string, opts *model.TeamSearch) ([]*model.Team, int64, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.TeamStore.SearchAllPaged(term, opts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SearchAllPaged", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerTeamStore) SearchOpen(term string) ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.SearchOpen(term)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SearchOpen", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) SearchPrivate(term string) ([]*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.SearchPrivate(term)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.SearchPrivate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) Update(team *model.Team) (*model.Team, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.Update(team)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) UpdateLastTeamIconUpdate(teamId string, curTime int64) error {
	start := timemodule.Now()

	err := s.TeamStore.UpdateLastTeamIconUpdate(teamId, curTime)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.UpdateLastTeamIconUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) UpdateMember(member *model.TeamMember) (*model.TeamMember, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.UpdateMember(member)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.UpdateMember", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) UpdateMembersRole(teamID string, userIDs []string) error {
	start := timemodule.Now()

	err := s.TeamStore.UpdateMembersRole(teamID, userIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.UpdateMembersRole", success, elapsed)
	}
	return err
}

func (s *TimerLayerTeamStore) UpdateMultipleMembers(members []*model.TeamMember) ([]*model.TeamMember, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.UpdateMultipleMembers(members)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.UpdateMultipleMembers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTeamStore) UserBelongsToTeams(userId string, teamIds []string) (bool, error) {
	start := timemodule.Now()

	result, err := s.TeamStore.UserBelongsToTeams(userId, teamIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TeamStore.UserBelongsToTeams", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.Get(id, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.GetLatest(allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.GetLatest", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) Save(termsOfService *model.TermsOfService) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.Save(termsOfService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) Cleanup() {
	start := timemodule.Now()

	s.TokenStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerTokenStore) Delete(token string) error {
	start := timemodule.Now()

	err := s.TokenStore.Delete(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) GetByToken(token string) (*model.Token, error) {
	start := timemodule.Now()

	result, err := s.TokenStore.GetByToken(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.GetByToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) RemoveAllTokensByType(tokenType string) error {
	start := timemodule.Now()

	err := s.TokenStore.RemoveAllTokensByType(tokenType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.RemoveAllTokensByType", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) Save(recovery *model.Token) error {
	start := timemodule.Now()

	err := s.TokenStore.Save(recovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerUploadSessionStore) Delete(id string) error {
	start := timemodule.Now()

	err := s.UploadSessionStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUploadSessionStore) Get(id string) (*model.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) GetForUser(userId string) ([]*model.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.GetForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.GetForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Save(session *model.UploadSession) (*model.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.Save(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Update(session *model.UploadSession) error {
	start := timemodule.Now()

	err := s.UploadSessionStore.Update(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) AnalyticsActiveCount(time int64, options model.UserCountOptions) (int64, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsActiveCount(time, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsActiveCountForPeriod(startTime int64, endTime int64, options model.UserCountOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsActiveCountForPeriod(startTime, endTime, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCountForPeriod", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetExternalUsers(hostDomain string) (bool, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetExternalUsers(hostDomain)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetExternalUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetGuestCount() (int64, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetGuestCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetGuestCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetInactiveUsersCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetInactiveUsersCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetSystemAdminCount() (int64, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetSystemAdminCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetSystemAdminCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AutocompleteUsersInChannel(teamId string, channelId string, term string, options *model.UserSearchOptions) (*model.UserAutocompleteInChannel, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.AutocompleteUsersInChannel(teamId, channelId, term, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AutocompleteUsersInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) ClearAllCustomRoleAssignments() *model.AppError {
	start := timemodule.Now()

	err := s.UserStore.ClearAllCustomRoleAssignments()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) ClearCaches() {
	start := timemodule.Now()

	s.UserStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerUserStore) Count(options model.UserCountOptions) (int64, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.Count(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) DeactivateGuests() ([]string, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.DeactivateGuests()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.DeactivateGuests", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) DemoteUserToGuest(userID string) *model.AppError {
	start := timemodule.Now()

	err := s.UserStore.DemoteUserToGuest(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.DemoteUserToGuest", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) Get(id string) (*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAll() ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllAfter(limit int, afterId string) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllAfter(limit, afterId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllNotInAuthService(authServices []string) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllNotInAuthService(authServices)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllNotInAuthService", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllProfiles(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllProfiles(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllProfilesInChannel(channelId string, allowFromCache bool) (map[string]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllProfilesInChannel(channelId, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllProfilesInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllUsingAuthService(authService string) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllUsingAuthService(authService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllUsingAuthService", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAnyUnreadPostCountForChannel(userId string, channelId string) (int64, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAnyUnreadPostCountForChannel(userId, channelId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAnyUnreadPostCountForChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByAuth(authData *string, authService string) (*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetByAuth(authData, authService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByAuth", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByEmail(email string) (*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetByEmail(email)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByEmail", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByUsername(username string) (*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetByUsername(username)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByUsername", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetChannelGroupUsers(channelID string) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetChannelGroupUsers(channelID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetChannelGroupUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetEtagForAllProfiles() string {
	start := timemodule.Now()

	result := s.UserStore.GetEtagForAllProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForAllProfiles", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetEtagForProfiles(teamId string) string {
	start := timemodule.Now()

	result := s.UserStore.GetEtagForProfiles(teamId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForProfiles", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetEtagForProfilesNotInTeam(teamId string) string {
	start := timemodule.Now()

	result := s.UserStore.GetEtagForProfilesNotInTeam(teamId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForProfilesNotInTeam", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetForLogin(loginId string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetForLogin(loginId, allowSignInWithUsername, allowSignInWithEmail)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetForLogin", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetKnownUsers(userID string) ([]string, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetKnownUsers(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetKnownUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetNewUsersForTeam(teamId string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetNewUsersForTeam(teamId, offset, limit, viewRestrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetNewUsersForTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfileByGroupChannelIdsForUser(userId string, channelIds []string) (map[string][]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfileByGroupChannelIdsForUser(userId, channelIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfileByGroupChannelIdsForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfileByIds(userIds []string, options *store.UserGetByIdsOpts, allowFromCache bool) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfileByIds(userIds, options, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfileByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfiles(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfiles(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesByUsernames(usernames []string, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfilesByUsernames(usernames, viewRestrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesByUsernames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesInChannel(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfilesInChannel(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesInChannelByStatus(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfilesInChannelByStatus(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesInChannelByStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesNotInChannel(teamId string, channelId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfilesNotInChannel(teamId, channelId, groupConstrained, offset, limit, viewRestrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesNotInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesNotInTeam(teamId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfilesNotInTeam(teamId, groupConstrained, offset, limit, viewRestrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesNotInTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesWithoutTeam(options *model.UserGetOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfilesWithoutTeam(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesWithoutTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetRecentlyActiveUsersForTeam(teamId string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetRecentlyActiveUsersForTeam(teamId, offset, limit, viewRestrictions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetRecentlyActiveUsersForTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetSystemAdminProfiles() (map[string]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetSystemAdminProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetSystemAdminProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetTeamGroupUsers(teamID string) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetTeamGroupUsers(teamID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetTeamGroupUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUnreadCount(userId string) (int64, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetUnreadCount(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUnreadCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUnreadCountForChannel(userId string, channelId string) (int64, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetUnreadCountForChannel(userId, channelId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUnreadCountForChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUsersBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.UserForIndexing, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUsersBatchForIndexing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) InferSystemInstallDate() (int64, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.InferSystemInstallDate()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InferSystemInstallDate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) InvalidateProfileCacheForUser(userId string) {
	start := timemodule.Now()

	s.UserStore.InvalidateProfileCacheForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfileCacheForUser", success, elapsed)
	}
}

func (s *TimerLayerUserStore) InvalidateProfilesInChannelCache(channelId string) {
	start := timemodule.Now()

	s.UserStore.InvalidateProfilesInChannelCache(channelId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfilesInChannelCache", success, elapsed)
	}
}

func (s *TimerLayerUserStore) InvalidateProfilesInChannelCacheByUser(userId string) {
	start := timemodule.Now()

	s.UserStore.InvalidateProfilesInChannelCacheByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfilesInChannelCacheByUser", success, elapsed)
	}
}

func (s *TimerLayerUserStore) PermanentDelete(userId string) *model.AppError {
	start := timemodule.Now()

	err := s.UserStore.PermanentDelete(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) PromoteGuestToUser(userID string) *model.AppError {
	start := timemodule.Now()

	err := s.UserStore.PromoteGuestToUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.PromoteGuestToUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) ResetLastPictureUpdate(userId string) *model.AppError {
	start := timemodule.Now()

	err := s.UserStore.ResetLastPictureUpdate(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ResetLastPictureUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) Save(user *model.User) (*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.Save(user)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Search(teamId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.Search(teamId, term, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchInChannel(channelId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.SearchInChannel(channelId, term, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchInGroup(groupID string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.SearchInGroup(groupID, term, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchInGroup", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchNotInChannel(teamId string, channelId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.SearchNotInChannel(teamId, channelId, term, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchNotInChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchNotInTeam(notInTeamId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.SearchNotInTeam(notInTeamId, term, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchNotInTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) SearchWithoutTeam(term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.SearchWithoutTeam(term, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.SearchWithoutTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Update(user *model.User, allowRoleUpdate bool) (*model.UserUpdate, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.Update(user, allowRoleUpdate)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UpdateAuthData(userId string, service string, authData *string, email string, resetMfa bool) (string, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.UpdateAuthData(userId, service, authData, email, resetMfa)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateAuthData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UpdateFailedPasswordAttempts(userId string, attempts int) *model.AppError {
	start := timemodule.Now()

	err := s.UserStore.UpdateFailedPasswordAttempts(userId, attempts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateFailedPasswordAttempts", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateLastPictureUpdate(userId string) *model.AppError {
	start := timemodule.Now()

	err := s.UserStore.UpdateLastPictureUpdate(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateLastPictureUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateMfaActive(userId string, active bool) *model.AppError {
	start := timemodule.Now()

	err := s.UserStore.UpdateMfaActive(userId, active)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaActive", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateMfaSecret(userId string, secret string) *model.AppError {
	start := timemodule.Now()

	err := s.UserStore.UpdateMfaSecret(userId, secret)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaSecret", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdatePassword(userId string, newPassword string) *model.AppError {
	start := timemodule.Now()

	err := s.UserStore.UpdatePassword(userId, newPassword)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdatePassword", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateUpdateAt(userId string) (int64, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.UpdateUpdateAt(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateUpdateAt", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) VerifyEmail(userId string, email string) (string, *model.AppError) {
	start := timemodule.Now()

	result, err := s.UserStore.VerifyEmail(userId, email)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.VerifyEmail", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Delete(tokenId string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.Delete(tokenId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) DeleteAllForUser(userId string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.DeleteAllForUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.DeleteAllForUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) Get(tokenId string) (*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Get(tokenId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetAll(offset int, limit int) ([]*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetAll(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetByToken(tokenString string) (*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetByToken(tokenString)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetByUser(userId string, page int, perPage int) ([]*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetByUser(userId, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Save(token *model.UserAccessToken) (*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Save(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Search(term string) ([]*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Search(term)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenDisable(tokenId string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.UpdateTokenDisable(tokenId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenDisable", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenEnable(tokenId string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.UpdateTokenEnable(tokenId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenEnable", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserTermsOfServiceStore) Delete(userId string, termsOfServiceId string) error {
	start := timemodule.Now()

	err := s.UserTermsOfServiceStore.Delete(userId, termsOfServiceId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermsOfServiceStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserTermsOfServiceStore) GetByUser(userId string) (*model.UserTermsOfService, error) {
	start := timemodule.Now()

	result, err := s.UserTermsOfServiceStore.GetByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermsOfServiceStore.GetByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserTermsOfServiceStore) Save(userTermsOfService *model.UserTermsOfService) (*model.UserTermsOfService, error) {
	start := timemodule.Now()

	result, err := s.UserTermsOfServiceStore.Save(userTermsOfService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermsOfServiceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) AnalyticsIncomingCount(teamId string) (int64, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.AnalyticsIncomingCount(teamId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.AnalyticsIncomingCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) AnalyticsOutgoingCount(teamId string) (int64, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.AnalyticsOutgoingCount(teamId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.AnalyticsOutgoingCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) ClearCaches() {
	start := timemodule.Now()

	s.WebhookStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerWebhookStore) DeleteIncoming(webhookId string, time int64) error {
	start := timemodule.Now()

	err := s.WebhookStore.DeleteIncoming(webhookId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.DeleteIncoming", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) DeleteOutgoing(webhookId string, time int64) error {
	start := timemodule.Now()

	err := s.WebhookStore.DeleteOutgoing(webhookId, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.DeleteOutgoing", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) GetIncoming(id string, allowFromCache bool) (*model.IncomingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetIncoming(id, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncoming", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetIncomingByChannel(channelId string) ([]*model.IncomingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetIncomingByChannel(channelId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingByChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetIncomingByTeam(teamId string, offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetIncomingByTeam(teamId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingByTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetIncomingByTeamByUser(teamId string, userId string, offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetIncomingByTeamByUser(teamId, userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingByTeamByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetIncomingList(offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetIncomingList(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingList", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetIncomingListByUser(userId string, offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetIncomingListByUser(userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetIncomingListByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoing(id string) (*model.OutgoingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetOutgoing(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingByChannel(channelId string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetOutgoingByChannel(channelId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingByChannelByUser(channelId string, userId string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetOutgoingByChannelByUser(channelId, userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByChannelByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingByTeam(teamId string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetOutgoingByTeam(teamId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByTeam", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingByTeamByUser(teamId string, userId string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetOutgoingByTeamByUser(teamId, userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingByTeamByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingList(offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetOutgoingList(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingList", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) GetOutgoingListByUser(userId string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.GetOutgoingListByUser(userId, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.GetOutgoingListByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) InvalidateWebhookCache(webhook string) {
	start := timemodule.Now()

	s.WebhookStore.InvalidateWebhookCache(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.InvalidateWebhookCache", success, elapsed)
	}
}

func (s *TimerLayerWebhookStore) PermanentDeleteIncomingByChannel(channelId string) error {
	start := timemodule.Now()

	err := s.WebhookStore.PermanentDeleteIncomingByChannel(channelId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteIncomingByChannel", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) PermanentDeleteIncomingByUser(userId string) error {
	start := timemodule.Now()

	err := s.WebhookStore.PermanentDeleteIncomingByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteIncomingByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) PermanentDeleteOutgoingByChannel(channelId string) error {
	start := timemodule.Now()

	err := s.WebhookStore.PermanentDeleteOutgoingByChannel(channelId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteOutgoingByChannel", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) PermanentDeleteOutgoingByUser(userId string) error {
	start := timemodule.Now()

	err := s.WebhookStore.PermanentDeleteOutgoingByUser(userId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.PermanentDeleteOutgoingByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerWebhookStore) SaveIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.SaveIncoming(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.SaveIncoming", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) SaveOutgoing(webhook *model.OutgoingWebhook) (*model.OutgoingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.SaveOutgoing(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.SaveOutgoing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) UpdateIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.UpdateIncoming(webhook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.UpdateIncoming", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWebhookStore) UpdateOutgoing(hook *model.OutgoingWebhook) (*model.OutgoingWebhook, error) {
	start := timemodule.Now()

	result, err := s.WebhookStore.UpdateOutgoing(hook)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WebhookStore.UpdateOutgoing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayer) Close() {
	s.Store.Close()
}

func (s *TimerLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *TimerLayer) GetCurrentSchemaVersion() string {
	return s.Store.GetCurrentSchemaVersion()
}

func (s *TimerLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *TimerLayer) TotalMasterDbConnections() int {
	return s.Store.TotalMasterDbConnections()
}

func (s *TimerLayer) TotalReadDbConnections() int {
	return s.Store.TotalReadDbConnections()
}

func (s *TimerLayer) TotalSearchDbConnections() int {
	return s.Store.TotalSearchDbConnections()
}

func New(childStore store.Store, metrics einterfaces.MetricsInterface) *TimerLayer {
	newStore := TimerLayer{
		Store:   childStore,
		Metrics: metrics,
	}

	newStore.AuditStore = &TimerLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.AutoMessageTaskStore = &TimerLayerAutoMessageTaskStore{AutoMessageTaskStore: childStore.AutoMessageTask(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &TimerLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CommandStore = &TimerLayerCommandStore{CommandStore: childStore.Command(), Root: &newStore}
	newStore.ComplianceStore = &TimerLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.ConversationNoteStore = &TimerLayerConversationNoteStore{ConversationNoteStore: childStore.ConversationNote(), Root: &newStore}
	newStore.ConversationTagStore = &TimerLayerConversationTagStore{ConversationTagStore: childStore.ConversationTag(), Root: &newStore}
	newStore.FacebookConversationStore = &TimerLayerFacebookConversationStore{FacebookConversationStore: childStore.FacebookConversation(), Root: &newStore}
	newStore.FacebookPostStore = &TimerLayerFacebookPostStore{FacebookPostStore: childStore.FacebookPost(), Root: &newStore}
	newStore.FacebookUidStore = &TimerLayerFacebookUidStore{FacebookUidStore: childStore.FacebookUid(), Root: &newStore}
	newStore.FanpageStore = &TimerLayerFanpageStore{FanpageStore: childStore.Fanpage(), Root: &newStore}
	newStore.FanpageInitResultStore = &TimerLayerFanpageInitResultStore{FanpageInitResultStore: childStore.FanpageInitResult(), Root: &newStore}
	newStore.FileInfoStore = &TimerLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.JobStore = &TimerLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.LicenseStore = &TimerLayerLicenseStore{LicenseStore: childStore.License(), Root: &newStore}
	newStore.LinkMetadataStore = &TimerLayerLinkMetadataStore{LinkMetadataStore: childStore.LinkMetadata(), Root: &newStore}
	newStore.OAuthStore = &TimerLayerOAuthStore{OAuthStore: childStore.OAuth(), Root: &newStore}
	newStore.OrderStore = &TimerLayerOrderStore{OrderStore: childStore.Order(), Root: &newStore}
	newStore.PageReplySnippetStore = &TimerLayerPageReplySnippetStore{PageReplySnippetStore: childStore.PageReplySnippet(), Root: &newStore}
	newStore.PageTagStore = &TimerLayerPageTagStore{PageTagStore: childStore.PageTag(), Root: &newStore}
	newStore.PluginStore = &TimerLayerPluginStore{PluginStore: childStore.Plugin(), Root: &newStore}
	newStore.PreferenceStore = &TimerLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.ReactionStore = &TimerLayerReactionStore{ReactionStore: childStore.Reaction(), Root: &newStore}
	newStore.RoleStore = &TimerLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.SchemeStore = &TimerLayerSchemeStore{SchemeStore: childStore.Scheme(), Root: &newStore}
	newStore.SessionStore = &TimerLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.StatusStore = &TimerLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.SystemStore = &TimerLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TeamStore = &TimerLayerTeamStore{TeamStore: childStore.Team(), Root: &newStore}
	newStore.TermsOfServiceStore = &TimerLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.TokenStore = &TimerLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.UploadSessionStore = &TimerLayerUploadSessionStore{UploadSessionStore: childStore.UploadSession(), Root: &newStore}
	newStore.UserStore = &TimerLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &TimerLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.UserTermsOfServiceStore = &TimerLayerUserTermsOfServiceStore{UserTermsOfServiceStore: childStore.UserTermsOfService(), Root: &newStore}
	newStore.WebhookStore = &TimerLayerWebhookStore{WebhookStore: childStore.Webhook(), Root: &newStore}
	return &newStore
}
